package main

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"syscall"

	abci_server "github.com/cometbft/cometbft/abci/server"
	abci_types "github.com/cometbft/cometbft/abci/types"
)

// TransferTransaction defines the structure for the incoming JSON transaction
// It must EXACTLY match the JSON generated by your Python app.
type TransferTransaction struct {
	Type      string `json:"type"`
	FromNode  string `json:"from_node"`
	ToNode    string `json:"to_node"` // Typo fix: Changed ToNode to to_node
	Amount    string `json:"amount"`  // e.g., "50 tokens"
	Timestamp string `json:"timestamp"`
}

// MyApp represents your custom ABCI application state.
type MyApp struct {
	abci_types.BaseApplication
	lastBlockHeight int64
	appHash         []byte
}

// NewMyApp creates and initializes a new instance of your ABCI application.
func NewMyApp() *MyApp {
	return &MyApp{
		lastBlockHeight: 0,
		appHash:         []byte("initial_app_hash"),
	}
}

// Info is called to get information about the application.
func (app *MyApp) Info(ctx context.Context, req *abci_types.InfoRequest) (*abci_types.InfoResponse, error) {
	log.Printf("ABCI Info: Received RequestInfo. Version: %s, BlockVersion: %d, P2PVersion: %d, ABCIVersion: %s",
		req.Version, req.BlockVersion, req.P2PVersion, req.AbciVersion)

	return &abci_types.InfoResponse{
		Version:          "1.0.0", // Your application's version
		AppVersion:       1,
		LastBlockHeight:  app.lastBlockHeight,
		LastBlockAppHash: app.appHash,
		Data:             "",
	}, nil
}

// InitChain is called once upon genesis, when the blockchain is initialized.
func (app *MyApp) InitChain(ctx context.Context, req *abci_types.InitChainRequest) (*abci_types.InitChainResponse, error) {
	log.Println("ABCI InitChain: Initializing minimal application state.")
	app.lastBlockHeight = req.InitialHeight
	app.appHash = []byte("initial_app_hash_after_init")
	log.Printf("ABCI InitChain: Initialized at Height %d with AppHash %x", app.lastBlockHeight, app.appHash)
	return &abci_types.InitChainResponse{}, nil
}

// CheckTx is called to validate a transaction before it enters the mempool.
func (app *MyApp) CheckTx(ctx context.Context, req *abci_types.CheckTxRequest) (*abci_types.CheckTxResponse, error) {
	log.Printf("Request to validate Transaction (CheckTx): ")
	log.Printf("ABCI CheckTx: Received raw transaction bytes : %s", string(req.Tx))

	decodedJSONBytes, err1 := base64.StdEncoding.DecodeString(string(req.Tx))
	if err1 != nil {
		logMsg := fmt.Sprintf("ABCI CheckTx ERROR: Base64 decode failed: %v", err1)
		log.Println(logMsg)
		return &abci_types.CheckTxResponse{Code: 1, Log: logMsg}, nil
	}
	log.Printf("ABCI CheckTx: Successfully Base64 decoded to raw JSON bytes: %s", string(decodedJSONBytes))

	var tx TransferTransaction
	err := json.Unmarshal(decodedJSONBytes, &tx)
	if err != nil {
		logMsg := fmt.Sprintf("ABCI CheckTx ERROR: Failed to unmarshal JSON: %v. Decoded payload was: %s", err, string(decodedJSONBytes))
		log.Println(logMsg)
		return &abci_types.CheckTxResponse{Code: 2, Log: logMsg}, nil
	}
	log.Printf("ABCI CheckTx: Successfully unmarshaled transaction: %+v", tx)

	if tx.Type == "" || tx.FromNode == "" || tx.ToNode == "" || tx.Amount == "" || tx.Timestamp == "" {
		logMsg := "ABCI CheckTx ERROR: Missing one or more required fields (type, from_node, to_node, amount, timestamp)."
		log.Println(logMsg)
		return &abci_types.CheckTxResponse{Code: 4, Log: logMsg}, nil
	}

	amountStr := strings.TrimSuffix(tx.Amount, " tokens")
	if _, err := strconv.Atoi(amountStr); err != nil {
		logMsg := fmt.Sprintf("ABCI CheckTx ERROR: Invalid amount format: %s", tx.Amount)
		log.Println(logMsg)
		return &abci_types.CheckTxResponse{Code: 5, Log: logMsg}, nil
	}

	log.Println("ABCI CheckTx: Transaction passed minimal format validations. Returning Code 0.")
	return &abci_types.CheckTxResponse{Code: 0, Log: "Transaction format OK."}, nil
}

// DeliverTx is called when a transaction is included in a block and committed.
func (app *MyApp) FinalizeBlock(ctx context.Context, req *abci_types.FinalizeBlockRequest) (*abci_types.FinalizeBlockResponse, error) {
	log.Printf("Executing Transaction (FinalizeBlock):")
	var txStrings []string
	for _, txBytes := range req.Txs {
		txStrings = append(txStrings, fmt.Sprintf("%x", txBytes))
	}
	log.Printf("ABCI : Processing transactions for block. Tx count: %d, Txs: %v", len(req.Txs), txStrings)

	app.lastBlockHeight = req.Height
	app.appHash = []byte(fmt.Sprintf("app_hash_at_height_%d", req.Height))
	log.Printf("ABCI : Height %d, New AppHash: %x", req.Height, app.appHash)

	txResults := make([]*abci_types.ExecTxResult, 0, len(req.Txs))

	for _, txBytes := range req.Txs {
		// Step 1: base64 decode the tx bytes (they are base64 encoded JSON)
		decodedTxBytes, err2 := base64.StdEncoding.DecodeString(string(txBytes))
		if err2 != nil {
			log.Printf("ABCI ERROR: Failed to base64 decode tx: %v, Payload: %s", err2, string(txBytes))
			txResults = append(txResults, &abci_types.ExecTxResult{
				Code: 1,
				Log:  "Failed to base64 decode tx",
			})
			continue // continue processing other txs
		}

		// Step 2: unmarshal JSON
		var tx TransferTransaction
		err := json.Unmarshal(decodedTxBytes, &tx)
		if err != nil {
			log.Printf("ABCI ERROR: Failed to unmarshal JSON: %v. Payload: %s", err, string(decodedTxBytes))
			txResults = append(txResults, &abci_types.ExecTxResult{
				Code: 2,
				Log:  "Failed to unmarshal JSON",
			})
			continue
		}

		log.Printf("ABCI : Successfully processed transaction: %+v", tx)
		txResults = append(txResults, &abci_types.ExecTxResult{
			Code: 0,
			Log:  "Transaction executed successfully",
		})
	}

	log.Printf("ABCI : Finished processing %d transactions at Height %d", len(req.Txs), req.Height)

	return &abci_types.FinalizeBlockResponse{
		TxResults: txResults,
		AppHash:   app.appHash,
	}, nil
}

// Commit is called to persist the current application state.
func (app *MyApp) Commit(ctx context.Context, eq *abci_types.CommitRequest) (*abci_types.CommitResponse, error) {
	log.Printf("ABCI : Committing state at height %d with AppHash %x", app.lastBlockHeight, app.appHash)
	return &abci_types.CommitResponse{RetainHeight: 0}, nil
}

// The main function to start the ABCI server.
func main() {
	app := NewMyApp()

	//addr := "unix:///home/shuddhank/gopyserf/abci_app/abci_app_executable.sock"
	addr := "tcp://0.0.0.0:26658"
	if len(os.Args) > 1 {
		addr = os.Args[1]
	}

	if strings.HasPrefix(addr, "unix://") {
		socketPath := strings.TrimPrefix(addr, "unix://")
		if _, err := os.Stat(socketPath); err == nil {
			if err := os.Remove(socketPath); err != nil {
				log.Fatalf("Failed to remove old unix socket file %s: %v", socketPath, err)
			}
			log.Printf("Removed old unix socket file: %s", socketPath)
		}
	}

	server := abci_server.NewSocketServer(addr, app)

	log.Printf("ABCI server listening on %s", addr)
	if err := server.Start(); err != nil {
		log.Fatalf("Error starting ABCI server: %v", err)
	}

	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	<-c

	log.Println("Shutting down ABCI server gracefully...")
	if err := server.Stop(); err != nil {
		log.Fatalf("Error stopping ABCI server: %v", err)
	}
	log.Println("ABCI server stopped.")
}
